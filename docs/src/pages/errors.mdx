# Error Handling

## Error Formatting

You can customize the server-side behavior in your API handler's options by
using an error formatter.

By default, only the error message is returned to the client, to avoid leaking
any sensitive information. You can customize this behavior by specifying the
`errorFormatter` option when you create your API handler. An error formatter
runs on the server and takes the original `UploadThingError`, and returns a
JSON-serializable object. The error also includes a `cause` property which
contains more information about the nature of the error and what caused the
error to throw in the first place.

For example, if you're using Zod as an input parser, you can return information
of what fields failed validation by checking if the cause is a `ZodError`. Zod
provides a `flatten` method that returns a JSON-serializable object which we can
return to the client.

```ts
import { ZodError } from "zod";

import { createNextRouteHandler } from "uploadthing/next";

import { uploadRouter } from "~/server/uploadthing";

export const { GET, POST } = createNextRouteHandler({
  router: uploadRouter,

  errorFormatter: (error) => {
    console.log("error", error.cause);
    return {
      message: error.message,
      foo: "my custom field",
      zodError: error.cause instanceof ZodError ? error.cause.flatten() : null,
    };
  },
});
```

## Catching errors on the client

You can catch errors on the client by using the `onUploadFailed` property on the
premade components, or the `useUploadthing` hook. You can access the JSON object
that you returned from your error formatter on the `data` property:

```tsx
<UploadButton
  endpoint="withInput"
  input={{ foo: userInput }}
  onUploadError={(error) => {
    console.log("Error: ", error);
    if (error.data?.zodError.fieldErrors.foo) {
      setError(error.shape?.zodError.fieldErrors.foo);
    } else {
      setError("");
    }
  }}
/>
```
